

\chapter{Úvod}
V úvode by som Vás rád oboznámil s témou mojej bakalárskej práce Systém monitorovania stavu plánovacích úloh, ktorá bola zverejnená spoločnosťou Red Hat. Tento systém je schopný riešiť rozličné plánovacie problémy, ktoré definovaný vo formáte XML. Plánovacím problémom chápeme rovnako problémy z bežného života(napríklad optimálna cesta pre vozidlá logistickej spoločnosti ), tak aj problémy z hľadiska informačných technológií(napríklad plánovanie testov na serveri). Podmienkou možnosti plánovania je existencia pravidiel a definičných entít pre konkrétny problém. Riešenie je realizovaný frameworkom OptaPlanner, ktorý na základe pravidiel a definičných entít pre danú úlohu sa pokúsi nájsť najlepšie riešenie, ktorý poskytne ako výsledok. Práca obsahuje popis monitorovacie systému, ktorý sa skladá z grafického rozhrania, ktoré zobrazuje stav plánovacích problémov a priebežný stav výpočtu a výpočtovej časti, ktorá rieši plánovacie problémy frameworkom OptaPlanner-om, ktoré medzi sebou komunikujú. Časť realizujúca riešenie je optimalizovaná pre riešenie problému N Dám. Obe časti systému sú založené na Java EE technológiách v kombinácií s rôznymi štýlovacími frameworkami, ktoré zabezpečili prenositeľnosti užívateľského rozhrania na mobilný telefón. Užívateľské rozhranie je sprístupňované na základe role užívateľa a obsah mechanizmy, ktoré zabezpečujú systém pred zneužitím. \newline \indent Rozhranie obecne umožňuje zobrazovať informácie o úlohách, vyhľadávať úlohy podľa určitého kritéria, editovať definície úloh rovnako aj spúšťať/pozastatovať plánovanie úloh. Okrem umožňuje spravovať užívateľov a organizácie, ktoré sú sprístupnené len konkrétnej užívateľskej role. Výsledkom práce je intuitivné rozhranie s rýchlou učiacou sa krivkou, ktoré je otestované širokou škálou užívateľov, ktorý okrem toho vyjadrili svoje osobné pocity z navrhnutého rozhrania a poskytli spätnú väzbu na možné vylepšenia rozhrania. Rozhranie bolo okrem otestované na platforme UNIX prostredníctvom nástroja Arquillian a JUnit so zreteľom na citlivé časti systému. \newline \indent Druhá kapitola sa venuje Java EE platforme a jej technológiám potrebných k vytvoreneniu systému\ref{JavaEE}. Nájdete tu stručné vysvetlenie spojené poprekladané s obrázkami pre lepšiu názornosť. Na záver kapitoly bude uvedená implementácii Java EE technológií open-source kontajnerom JBoss. \newline \indent V tretej kapitole bude vysvetlený systém OptaPlanner počínajúc elementárnymi časťami potrebnými k dotvoreniu celkového obrazu o probléme plánovania\ref{optaplannerC}. Bude bližšie vysvetlený pojem \uv{plánovací problém}, rovnako bude rozobratý 1 konkrétny typ problému s obrázkom pre lepšie pochopenie. V tejto kapitole sa oboznámime s princípom plánovania prostredníctvom tohto frameworku, rovnako ja konfiguráciu toho frameworku. \newline \indent V štvrtej kapitole sa prezentujeme špecifikáciu systému monitorovania, rovnako aj analyzuje použité technológie\ref{impl}. Následne prejdeme ku konkrétnemu návrhu a rozdeleniu systému na jednotlivé časti. V ďalšej časti uvedieme spôsob implementovania a celú kapitolu ukončíme zmienkou a testovaní aplikácie a vyhodnotení. V záverečnej kapitole zhrnenieme obsah celej práce, zhodnotíme jej prínos a možnosť ďalšieho rozšírenia\ref{zaver}.\newline \indent  V sekcii príloh nájdeme postup na inštaláciu a spustenie aplikácie rovnako ako aj kompletný prehľad navrhnutého rozhrania a predloženého dotazníka\ref{priloh}.


\chapter{Java Enterprise edition 6}\label{JavaEE}
\section{Motivácia}
Nasledujúca kapitola poskytuje prehľad o platforme Java EE 6 vrátané technológií, ktoré sú používané pri implementácií systému monitorovania. Kapitola sa zameriava na pochopenie obecného princípu vytvárania aplikácií založených na Java Enterprise Edition(Java EE) platforme. Ďalej prechádza k vysvetlenie konkrétnch technológií Java EE pre tvorbu užívateľského rozhrania, rovnako aj komunikácie medzi časťami systému. Následne sú vysvetlené obecné princípy používaný jazyk Java, na ktorom je postavená platforma Java EE spolu s nástrojmi na implementáciu a testovanie výsledného systému. \newline \indent V závere kapitoly je rozobratý Java EE kontajner JBoss, ktorý je použitý pre nasadeniem beh a spravovanie výsledného systému\ref{jbossc}. Dôvodom použitia jazyka a na nej založenej platforme je použitie Java EE kontajnera, rovnako aj možnosť použitia pokročilých nástrojov na testovanie a nástroja na spravovanie závislosti, ktorý je primárne určený pre jazyk Java. 


\section{Špecifikácia platformy}
Základom Java EE je štandard Java Standard Edition(Java SE). Java EE predstavuje platformu a poskytuje knižnice určené zjednodušenie vývoja komplexných webových a podnikových aplikácií\cite{fitWeb}. Tieto aplikácie sú viacvrstvové z dôvodu lepšej prenositeľnosti, nasaditeľnosti a modifikovateľnosti. Na Java EE môžme nahliadať ako na kolekciu špecifikáciu od Sun/Oracle. Java označuje okrem programovacieho jazyka, tak isto aj platformu. Java platforma sa skladá z virtuálneho stroja a príslušného Application Programming Interface(API). Virtuálny stroj je behové prostredie našej aplikácie zloženého z tried, ktoré bolo preložené do byte kódu. Tento virtuálny stroj býva navrhnutý pre konkrétny operačný systém. API je sada vytvorených tried, ktoré môžme využiť pri implementácií aplikácie a sprístupňuje funkčnosť virtuálneho stroja\cite{javaeespec}.\newline \indent Základom používania Java EE aplikácií je prítomnosť štandardného API využívané enterprise aplikáciami. Java EE teda poskytuje, ktoré usnadňujú vývoj v rôznych oblastiach, či je to oblasť webových služieb(napríklad Java API for XML Web Services), správa transakcií(napríklad Java Transaction API) alebo rôzne iné oblasti. Aplikácia, ktorá pokrýva všetky API, ktoré spĺňajú špecifikáciu Sun/Oracle pre Java EE sa nazýva aplikačný server. Aplikačný server rovnako poskytuje aj klasické služby na jeho spravovanie. Referenčnou implementáciou je server GlassFish. Základom aplikácie sú komponenty, ktoré predstavuju základné jednotky aplikácie, ktoré sa nasadzujú na server. Komponent existuje niekoľko druhou, ale len niektoré sa nasadzujú na aplikačný server. Každý aplikačný server obsahuje kontajnery, ktoré sa starajú o poskynutie funkcionality konkrétnej komponente. Java EE platforma špecifikuje aplikačný model Java EE aplikácie, ktorá je rozdelená do vrstiev podľa fukčnosti.

\section{Aplikačný model}
Java EE definuje aplikácie, ktoré sú viacvrstvové(multitier). Pojmom viacvrstvosť je myslené rozdelenie aplikácie podľa funkčnosti na menšie celky(ktoré nazýva stupne), ktoré majú nastarosť určitú úlohu. Každá vrstva je predstavovaná inými technológiami. Vo výsledku jednotlivé vrstvy medzi sebou komunikujú a toto rozdelenie uľahčuje a zprehľadňuje presnosť vývojové cykly aplikácie. Každá vrstva je reprezentovaná komponenta, ktorá predstavuje funkčnú časť programu zostavenú z tried a súborov, ktorá je vložená do Java EE aplikácie a interaguje s inými komponentami\cite{Pravidla}. Jednotlivé komponenty sa následne rôzne inštalujú na rôzne vrstvy v závislosti od ich príslušnosti(každý stupeň môže byť fyzicky na inom aplikačnom serveri). Jednotlivé stupňe sa skladajú z rôznych komponent, pričom stupne sú rozdelené nasledovne:
\begin{itemize}
\item Klientský stupeň sa skladá z klientských komponenent, ktoré bežia na klientskom počítači
\item Stredná vrstva sa skladá z webových a podnikových komponent, ktoré bežia na Java EE serveri, ktorý predstavuje prostredie pre nasadenie, spravovanie a beh podnikových a webových komponent Java EE aplikácie
\item Najnižšia vrstva predstavuje externé systémy využívané Java EE aplikáciou. Typicky sa jedná o databázový server a externé systémy označujeme názvom \uv{Enterprise Information System(EIS)}
\end{itemize}

Typicky beží medzi klientskom a databázou častou viac-vláknový Java EE server. Na základe tohto rozdelenia môžme uviesť, že platforma Java EE sa používa vývoj vo webovej a podnikovej vrstve, ktoré bežia na Java EE serveri.  Na obrázku č. \ref{model} môžme vidieť viacvrstvové rozdelenie.
\begin{figure}[htb]

\begin{center}

\includegraphics[scale=0.5]{model.jpg} 
\caption{Model Java EE prevzaté z [http://docs.oracle.com/javaee/6/tutorial/doc/]}
\label{model}

\end{center}

\end{figure}
Klient pristupuje k Java EE aplikácií na Java EE serveri z klientskej stanice, prostredníctvom tenkého klienta(webový prehliadačo), ktorý sa nazýva \uv{tenký klient}(pretože sa nedotazuje priamo na databázový server), alebo klientská aplikácia, ktorý sa nazýva \uv{hrubý klient}. Tenký klient pozostáva z:  Webové prehliadača, ktorý zobrazuje stránky a dynamické webové stránkz pozostávajúce  z rôzneho značkovacieho jazyka, ktoré sú generované webovými komponentami. Tenký klient sa dotazuje prostredníctvom Hypertext Transfer protokolu(HTTP), čo je internetový protokol pre výmenu hyperxtových dokumentov, na webové komponenty na Java EE serveri. Hrubý klient, ktorý môže byť reprezentovaný rozličnými Java SE technológiami pre tvorbu užívateľských rozhraní, sa môže priamo dotazovať podnikových komponent a preskočiť tak komunikáciu s webovými komponentami. \newline \indent Stredná vrstva sa delí na webovú vrstvu, ktorá je prezentovaná technológiami JavaServer Faces a JavaServer Pages. Druhá časť strednej vrstvy takzvaná podniková vrstva býva reprezentovaná technológiu EnterpriseJava Beans, ktoré vytvárajú logiku aplikácie. Webová vrstva reprezentovaná je reprezentovaná webovými komponentami, ktoré spracovávajú požiadavky od užívateľa a generujú odpoveď, ktorú posielajú naspäť užívateľovi. Môžu pritom kontaktovať aj podnikové komponenty pre zistenie dodatočných informácií. Podniková vrstva je reprezentovaá podnikovými komponentami, ktoré tvoria základ aplikácie. Tieto komponenty môžu prijímať požiadavky od klienta alebo webovej vrstvy a následne generujú odpovede, pričom môžu komunikovať s najnižšou vrstvou(napríklad komunikovať s databázovým serverom). Táto vrstva beží na Java EE serveri. \newline \indent Najnižšia vrstva predstavuje rozličné externé systémy, ktoré aplikácia môže využívať, či už sa jedná o databázový systém, alebo iné. Vrstva býva označovaná skratkou EIS.



\section{JavaServer Pages}\label{jspkap}
JavaServer Pages(JSP) technológia je jazyk, ktorý umožňuje priamo vkladanie Java kódu do HyperText Markup Language(HTLM) kódu. HTML je značkovvací jazyk pre vytváranie webových stránok, ktorý obsahuje HTML značky. Pre vloženia java kódu v HTML stránke sa používajú nasledujúce značky: \emph{<\%} \emph{\%>} medzi, ktoré sa vloží príslušný java kód. Takéto časti v HTML stránke sa nazývaju \uv{skriptlety}. Tieto skriplety sú dynamické, to znamená, že sú vykonávané za behu aplikácie. Behom aplikácie je myslené nasadenie jsp stránky(stránka obsahújca skriplety) na Java EE server, ktorý zabezpečuje jeho vykonávanie prostredníctvom volania jsp kontajneru.

\begin{figure}[htb]

\begin{center}

\includegraphics[scale=0.5]{architecture.jpg} 
\caption{JSP architektúra  prevzáte z [http://interval.cz/clanky/javaserver-pages-pro-vsechny/] }
\label{jsp}

\end{center}

\end{figure}
Na nasledujjúcom obrázku č.\ref{jsp} je zobrazený princíp technológie JSP. Základnou časťou je existenia JSP stránky a jej nasadenie na Java EE serveri. V 1.kroku existuje užívateĺ, ktorý je reprezentovaný webovým prehliadačom, ktorý zažiada o JSP stránku. Java EE server prijme požiadavku od klienta a zistí, že sa jedná o požiadavku o JSP stránku . Ten zavolá JSP servlet kontajner na spracovanie žiadosti, ktorý obsahuje JavaServer Pages prekladač, ktorý obsluhuje spracovanie, kontrolu a generovanie. Ten JSP servlet stroj spracováva JSP stránku a vyhodnocuje skriplety a nahradzje ich výsky HTML kódom, ktorý produkuje na výstup. Výstupom zo JSP servletu, ktorý vznikol ako požiadavka o JSP stránku je html stránka, ktorá je predaná užívateľovi, ktorý si ju zobrazí. Výhodou tejto technológie je, že pri žiadosť o JSP stránku je, že pri zmene sa nemení celý obsah stránky ale len jej časť, ktorá bola zmenená. Takže takéto JSP stránky sú dynamické a umožňujú zmenu obsahu za behu.



\subsection{JavaServer Faces}\label{jsfkap}
JavaServer Faces(JSF) je framework pre tvorbu užívateľských rozhraní webových aplikácií, ktoré bežia na Java EE serveri. JSF framework vytvára aplikácie na základe  Model-View-Controller(MVC). MVC predstavuje sotwarovú architektúru, ktorá rozdeľuje aplikáciu na dátový model, užívateľské rozhranie a riadiacu logiku do nezávislých častí. Princíp je nasledujúci:
\begin{itemize}
\item Model - špecifická reprezentácia dát, s ktorými pracuje aplikácia
\item View - prevádza data aplikácie vhodné do podoby prezentácie užívateľa
\item Controller - reaguje na udalosti, typicky od klienta a zabezpečuje zmeny v model alebo view

\end{itemize}
Pri využítí tohto frameworku programátor vkladá predpripravené komponenty(tlačidlá, vyskakovacie okná, rolovacie zoznamy, \ldots) a mapuje ich na príslušné triedy. JSF sa skladá z 2 častí:
\begin{itemize}
\item JSF API - obsahuje komponenty užívateľského rozhrania, umožňuje ich správu, validáciu vstupov, zpracovanie udalostí, navigáciu a iné
\item Knižnica tagov(tag library), ktorá môže byť alternatívne nahradená JSP knižnicou tagov - prostredníctvom týchto špeciálnych tagov vkladáme komponenty užívateľského rozhrania na stránku a upravuje ich chovanie pomocou atribútov alebo mapovaním na triedy. Každá komponenta je definovaná triedou, ktorá určuje jej funkcionalitu. Tagy jednotlivých knižníc sú rozlišované na základe menných priestorov.
\end{itemize}

JSF umožňuje mať výstup v podobe HTML jazyka, alebo iného jazyka v závislosti od definičných tried komponent. Základnou implementáciu prevádza JSF komponenty do HTML kódu.
\subsection{JSF aplikácia}
JSF aplikácia je klasická webová aplikácia, ktorá obsahuje aj svoje špecifiká. Základná štruktúra JSF aplikácie je nasledujúca, pričom nie všetky časti sú povinné:
\begin{itemize}
\item Súbory značkovanie jazyka HTML alebo Extensible Hypertext Markup Language(XHTML)\cite{xhtmlbook}, ktoré obsahuju komponenty užívateľského rozhrania z knižnice tagov, ktoré môžu byť namapované na tzv. \uv{managed bean-y}
\item Managed Beans - java triedy, ktoré sú spravované JSF frameworkom. Najdôležitejšie sú \uv{backing bean}, ktoré zabezpečujú funkcionalitu na HTML/XHTML stránke, udržujú stav komponent, zpracovájú udalosti, validáciu \ldots. Ich konfigurácia sa realizuje v súbore \emph{faces-config.xml}
\item Konfiguračný súbor \emph{faces-config.xml}, v ktorom sa definujú backing beany spolu s ich typom, navigácia, validátory(java triedy, ktorá spracovávajú zadané hodnoty a generujú výstup), \ldots
\item Popisovač nasadenia \emph{web.xml}, ktorý umožňuje nastavenie uvítacích stránok, filtre, servlety a \ldots
\end{itemize}
Neoddeliteľnou súčasťou tohto frameworku je Expression Language(EL), je jazyk, ktorý umožňuje dynamicky pristupovať k metódam javovských tried,(backing bean) rovnako dokáže získať a nastaviť hodnotu danej komponenty.Pri preklade sa vygenerejú závislosti na backing beans. Backing beans dokáže za behu spracovávať údaje zadané na webovú stránku, rovnako dokáže obstarať validáciu vstupov,  následne metódy a vlastnosti, ktoré sú volané alebo sú im predávané údaje z vygenerovavnej stránky(HTML alebo XHTML) do backing bean-y alebo opačne. \newline \indent Obecne Managed Beans môžu byť nasledujúceho typu, pričom typy managed beans sa uvádzajú v súbore faces-config.xml:
\begin{itemize}
\item @RequestScoped Managed beana prežíva pokiaľ  existuje HTTP požiadavok. Vytvára sa pri vytvorený požiadavku a zaniká pri zrušení HTTP požiadavku
\item @NoneScoped Managed Beana existuje tak dlho ako existuje vyhodnotenie Facelets na stránke, po vyhodnotení zaniká
\item @ViewScoped Managed beana prežíva pokiaľ existuje interakcia s danou JSF stránkou. Vytvára sa pri žiadosti o danú stránku a zaniká pokiaľ užívateľ prejde na inú JSF stránku
\item @SessionScoped Managed bean prežíva tak dlho pokiaľ existuje HTTP sedenie. Vytvára sa pri 1.požiadavke o danú stránku a zaniká pri invalidácií daného HTTP sedenia
\item @ApplicationScoped Managed Bean prežíva dokiaľ existuje aplikácia. Je vytvorená pri prvej interakcii s aplikáciou a zaniká pri ukončení aplikácie
\item @CustomScoped Managed Bean existuje dokiaľ existuje záznam o bean-e v v custom Map, ktorá je vytvorená pre existenciu danej beany
\end{itemize}
V poslednom rade treba uviesť životný cyklus JSF aplikácie.

Celý štandardný cyklus cyklus spracovania požiadavky a následne generovania odpovedi je popísaný na nasledujúcom obrázku.
\begin{figure}[htb]

\begin{center}

\includegraphics[scale=0.7]{jsflifecycle.jpg} 
\caption{JSF životný cyklus [http://docs.oracle.com/javaee/1.4/tutorial/doc/] }
\label{lifecycle}

\end{center}

\end{figure}
Na obrázku č.\ref{lifecycle} môžme vidieť životný cyklus JSF aplikácie. Počas fázy Restore View, keď je kliknuté na tlačidlo alebo na link sa vytvorí náhľad stránky, spoja sa všetky spracovania udalostí, validátory a komponenty a uložia sa do inštancie FacesContext. V ďalšej fáze Apply Request Values nové hodnoty sú získané použítím metódy decode. Hodnoty sú potom uložené lokálne do komponenty. Pokiaľ nastane chyba, tak je propagovaná a generovaná do FacesContext-u. Na konci tejto fáze sa vykoná znova dekódovanie pokiaľ stály nejaké nové hodnoty vo fronte na spracovanie. Vo fáze Process Validations spracuje všetky registrované validátory ku komponentám. Pokiaľ nastala chyba tak je táto informácia uložená do FacesContext-u. Počas ďalšej fázy Update Model Values nastaví do komponent lokálne nové hodnoty. Počas predposlednej áze Invoke Application je spracované rozličné žiadosti ako potvrdzonie formulára alebo link na iný stránku. V poslednej fáze Render Response dôjde k renderu stránku s novými hodnotami v kotajnery.

\section{Webová služba}\label{webkap}
Web Service je sotwarový systém navrhnutý na podporu inteoperability medzi rôznymi zariadeniami prostredníctvom počítačovej siete. Komunikácia prebehia prostredníctvom HTTP protokolu vymenieňaním Extensible Markup language(XML) správ. XML je značkovací jazyk, ktorý definuje sadu pravidiel pre kódovanie dokumentu vo formáte porozumiteľnom človeku prostredníctvom ľubovolných tagov. Webóvé služby poskystujú interoperabilitu medzi rôznymi platformami naprieč počítačou sieťou. Webová služba umožňuje komunikáciu medzi rôznymi aplikáciami, ktoré bežia na rôznych platformách. Tento aspekt je umožnený tým, že aplikácie komunikujú prostredníctov HTTP protokolu. Komunikácia prostredníctvom webovej služby sa delí na 2 učastníkov. Prvý účastník produkovateľ(producer), ktorý vytvára požiadavok a spotrebiteľ(consumer), ktorý prijíma požiadavok. Komunikácia prebieha medzi týmto dvoma učastníkmi výmenov správ. Webová služba môže byť technicky implementovaný rôznymi možnosťami a prostredníctvom Big Web Service alebo Restful WebService, pričom v princípe ako o java triedy, ktoré obsahujú špeciálne definície triedy a metód a pri nasadení na Java EE server môžu byť vzdialenie(po sieti) zavolané ich metódy. 



\subsection{"Big" webová služba}\label{bigkap}
\uv{Big} webová služba je druh webovej služby, ktorý pre svoju implementáciu používa API JAX-SW\cite{fitWeb} "Big" . Tento typ webovej služby umožňuje vytvárať webové služby orientované na správy alebo techniku vzdialeného volania procedúr(RPC). RPC je technológia, ktorá umožňuje volanie metód, ktoré sa nachádzajú na inom mieste, typicky inom mieste počítačovej siete. Tento typ webovej služby využíva XML správy, spolu so Simple Object Acess Protocol(SOAP) a XML jazykom. SOAP definuje protokol pre výmenu správ založených na jazyku XML prostredníctvom siete prostredníctvom HTTP protokolu. SOAP správy sa skladajú z hlavičky a tela správy, ktoré obsahuje odpoveď webovej služby alebo požiadavok na vyvolanie akcie webovej služby.
\begin{figure}[htb]

\begin{center}

\includegraphics[scale=0.5]{webservice.jpg} 
\caption{\uv{Big} webová služba  prevzaté z [http://docs.oracle.com/javaee/6/tutorial/doc/bnayl.html] }
\label{com}

\end{center}

\end{figure}
Nasledujucí obrázok č. \ref{com} ukazuje spôsob komunikácie medzi klientom, ktorý sa nachádza v ľavej časti obrázku a webovou služba, ktorá sa nachádza vpravej časti obrázku. Komunikácia prebieha prostredníctvom vymienania SOAP správ. Rovnako ako na klientovi tak aj web service obsahuje potrebné API, ktoré spracováva SOAP správy a predáva ich ďalej.

 Tento typ webovej služby obsahuje definíciu vo formáte Web Service Description Language(WSDL). WSDL je definícia vo formáte XML, ktorá popisuje aké akcie webová služba poskytuje a zpôsob ich invokácie, rovnako  aj odpoveď. Správy volania a odpovedí web service sú vymieňané prostredníctvom SOAP správ prostredníctvom HTTP protokolu. JAX-WS API je pomerne komplikované, preto celá komplexnosť je vývojarovi zakrytá a je jediné, čo definuje vývojár sú metódy, ktoré je možné vzdialene volať. Rovnako vývojár nespracováva SOAP správy, ale celá táto problematika je riešená prostredníctvom prostredníctvom API. Veľká výhoda je platformová nezávislosť, ktorá je dosiahnutá prostredníctvom Javy. Tak isto toto API umožňuje prístup k ne-Javovským web service, čo prináša veľkú flexibilitu. Čo sa týka vývoja web service, tak sa jedná o jednoduchú Java triedu, ktorá používa anotáciu javax.jws.WebService, konkrétne anotáciu @WebService, ktorá označuje, že sa jedná o web service endpoint. Táto trieda následne definuje metódy, ktoré môžu byť vzdialené volané. Aby moha byť metóda metódou web service musí byť anotovaná prostredníctvom anotácie  javax.jws.WebMethod @WebMethod. API ponuká aj ďalšie možnosť ako ovplyvňovať životný cyklus web service. 





\section{Princíp webových komponent}
Java EE webové komponenty sú softwarové komponenty, ktoré spracovávajú prichádzajúci HTTP požiadok a poskytujú naň odpoveď. Všetky Java EE webové komponenty sú postavané na servletoch. Servlety sú javovské triedy , ktoré dynamicky spracovávajú požiadavky a tvoria odpovede. Súčasťou servletov alebo webových stránok  sú technológie JavaServer Faces technológiu(JSF)\ref{jsfkap} and JavaServer pages(JSP)\ref{jspkap}. Technológie JavaServer Faces a JavaServer Pages podporujú spracovanie užívateľských vstupov a ich predanie a spracovanie podnikovou vrstvou.



\begin{figure}[htb]

\begin{center}

\includegraphics[scale=0.5]{webtechnology.jpg} 
\caption{Webové komponenty prevzáte z [http://docs.oracle.com/javaee/6/tutorial/doc/bnaay.html#bnabj] }
\label{web}

\end{center}

\end{figure}
Na nasledujúcom obrázku č.\ref{web} je ukázaný princíp fungovania webových komponent. V hornej ľavej časti obrázku sa nachádza klientská vrstva, ktorá obsahuje buď len webový prehliadač po prípade Applety, ktoré čiastočne obsahujú logiku aplikácie. Applet je aplikácia, ktorú spúšťa užívateľ prostredníctvom webového prehliadača a je vykonávaná virtuálnym strojom. V hornej pravej časti môže byť klient reprezentoný aplikačným klientom, ktorý obsahuje obsahuje úplnú prezentačnú logiku aplikácie a teda v tom prípade, odpadá potreba spracovania vstupov po prípade nejaké generovania HTML stránky. Takýto klient komunikuje už len priamo s Java EE serverom, konkrétne podnikovou vrstvou, ktorá implementuje zvyšnú logiku aplikácie a je reprezentovaný technológiou Enterprise Java Beans. V prípade, že máme k dispozícií tenkého klienta, klient komunikuje prostredníctvom webové prehliadača s HTML alebo XHTML stránky, ktoré sú vytvorené technológiou JavaServer Faces\ref{jspkap} alebo JavaServer Pages\ref{jspkap}, ktoré spracovávajú požiadavky od klienta(vstupy) a následne komunikuje s podnikovým stupňom, ktorý obsahuje logiku reprezentovanú Enterprise Java Beans technológiou, ktorý následne môže komunikovať s databázovým serverom. Odpoveď je následne \uv{predaná} stránkám vytvorené prostredníctvom JavaServer Faces alebo JavaServer Pages technológiou a následne zobrazená užívatelovi v podobe výstupu webovej stránky. 


\section{Java Persistence API}\label{jpakap}
Java Persistence API(JPA) je framerok jazyku Java, ktorá poskytuje prístup a spravovanie dát v databázy pomocou prístupu \emph{objektovo relačné mapovanie}. JPA je nezávislé nad použitou databázou technológiou, je možné vytvárať dotazy nad MySQL, SQL databázou, \ldots. Tento prístup  umožňuje mapovanie dát medzi  z databázových tabuliek na objekty javy(entity). Entita je základnou jednoutkou frameworku JPA, s ktorým pracujeme pri manipulácia s dátami. Entitna je je odľahčený perzistentný doménový objekt, ktorý typicky reprezentuje tabuľku v relačnej databázy a každá jej inštancia je riadkom v  tabuľke. Základný artefaktom v programovaní je pre entity entitná trieda, ktorá obsahuje vlastnosti, ktoré priamo odpovedajú schéme vytvorenej databáze. Každá entitná trieda musí spĺňať určité kritéria:
\begin{itemize}
\item Entitná trieda priamo musí byť anotovaná javax.persistence.Entity anotáciou. Anotácia je reťazec obsahujúci znak \emph{@} nasledovaný reťazcov, pričom môže v zátvorkách obsahovať ďalšie parametre, ktorý pridáva ďalšie informácie o označenej(anotovanej položke). Anotovať môže rovnako metódy, triedy ale aj vlastnosti tried.
\item Entitná trieda musí mať parametrický konštruktor, aby bolo možné vytvárať nové entity
\item Každá vlastnosť entitnej triedy musí spĺňať princíp Plain Old Java Objec(POJO), čo znamená, že pre každú vlastnosť existuje metóda v tvare getNázovVlastnosti, ktorá získa hodnotu vlastnosti a metóda v tvare setNázovVlasnosti, ktorá nastaví danú hodnotu. Jednotlivé vlastnosti môžu byť dodatočne anotované kvôli kontrole na hodnotu konkrétneho typu alebo vlastnosti(nenulovosť, špeciálny formát, \ldots).
\item Každá entitná trieda musí mať mať unikátny identifikátor. Týmto identifikátorom chápeme primárny kľúč, čo je vlastnosť, ktorá dokáže v databázy jednoznačne identifikovať záznam. Primárny kľúč býva anotovaný prostredníctvom anotácie javax.persistence.Id
\end{itemize}
\newline  \indent Rovnako treba spomenúť, že každá entitná trieda môžu byť vo vzťahu s inými entitami. V prípade, že vlastnosť entity je súčasťou vzťahu s inou entitou použijeme niektorú z nasledujúcich anotácii podľa násobnosti vzťahu: \emph{@One-to-one, @One-to-many, @Many-to-one, @Many-to-Many}. Rovnako uvedenie vlastnost/vlastnosti druhej entity, ktoré sa podieľajú na vzťahu. To urobíme tak, že našu vlastnosť ešte anotujeme anotáciou javax.persistence.JoinColumn, v ktorej parametroch uvedieme názvy vlastnosti druhej entity, ktoré sú súčaštou vzťahu.
JPA ponúka aj iné, pokročilé možnosti mapovania, pre naše potreby nám budú stačiť nasledujúce informácie.
\newline \indent Aby sme mohli s entitami pracovať potrebujeme si vytvoriť inštanciu triedy javax.persistence.EntityManager. EntityManager je trieda, ktorá dokáže vytvárať a odstraňovať entity, umožňuje ich vyhľadávať, rovnako aj vytvárať dotazy nad databázou. Dotazy, ktoré môžme vytvoriť pomocou JPA sa podobajú klasickému jazyky Structured Query Language(SQL), ktorý dokázaže vytvárať dotazy nad databázou, avšak dotazovací jazyk jazyk JPA má niekoľko rozdielov. Tento jazyk sa nazýva Java Persistence Query Language(JPQL), čo je ako bolo spomenuté jazyk podobný SQL, pričom tento jazyk je reťazcovo založený a je nezávislý na zvolenej databázovej techológií a objektové vlastnosti, čo znamená, že pri tvorbe dotazovou používame názvy vlastností entitných tried a názvy entitný tried. Problém JPQL je typová nebezpečnosť, čo vyžaduje pretypovanie výsledkov dotazu z entity manager-a. To môže spôsobiť chyby, ktoré nemusia byť odchytené počas kompilácie. JPA definuje ešte Criteria API, ktoré je využívané k vytváraniu dotazovou nad entitami a vzťahy, ktoré sú typovo bezpečné. Výhodou tohto API, pre použitie na dotazovanie, je rovnako možnosť vytvárať dynamické dotazy, ktoré majú lepšiu výkonnosť ako JPQL. Aby EntityManager bol schopný pracovať s určitými entitnými triedami je nutné vytvoriť \emph{perzistentnú jednotku(persistence unit)}, čo je XML predpis, do ktorého uvedieme entitné triedy, odkaz na databázu po prípade ďalšie vlastnosti a ten vložíme do súboru persistence.xml. Tento súbor predstavuje konfiguráciu, ktorá obsahuje okrem názvu entitných tried, tak aj rôzne iné vlastnosti, napr. je možné automaticke vytvoriť pri načítaní so súboru schému databáze. V tomto súbore sa rovnako nachádza doležitá položka a to je datasource, ktorý definuje odkaz na databázu, s ktorou pracujeme. Na záver kapitoly zhrniem princíp práce s JPA:
\begin{itemize}
\item Vytvorenie entitných tried spolu s vlastnosťami, správne naanotovanie tried, pričom návrh entitných tried odpovedá návrhu schémy databáze, ktorý požadujeme
\item Registrácia entitných tried v súbore persistence.xml, v ktorom nastaví aj odkaz na nami používanú databázu
\item Vytvorenie inštancie triedy EntityManager, pričom môžme explicitne uviesť názov perzistentnej jednotky, s ktorou pracujeme(perzistentných jednotiek môže byť viac)
\item Pracujeme s databázou spôsobou, vytváraním, mazaním, editovaním hodnôt entitných tried, ktoré zapisujeme do databáze EntityManager-om, alebo vytvárame dotazy, ktoré realizujeme EntityManager-om a výsledky podľa potreby spracovávame.
\end{itemize}


\section{Enterprise JavaBeans}\label{ejbkap}
EnterpriseJavaBeans(EJB) je technológia, ktorá umožňuje vytvárať komponenty, ktoré bežia v strednej, konkrétne podnikovej vrstve aplikačného modelu Java EE. Takéto komponenty sú modulárne, keďze je možné ich vytvoriť a spravovať viac inštancií a môžme do nich umiestniť logiku našej aplikácie. Takéto komponenty komunikujú s klientom alebo webovými komponentami a na druhej strane môžu komunikovať s EIS vrstvou a vykonávajú/predávajú získané informácie. Na EJB sa môžme pozerať aj ako na API platformy Java EE, prostredníctvom, ktorého môžme vytvárať triedy, ktoré sú špeciálne anotované a obsahujú podnikovú logiku a sú nasadené na Java EE server. Základnou podmienkou nasadenia na Java EE server je prítomnosť EJB kontajneru, do ktorého sa inštalujú vytvorené triedy. Triedy vytvorené týmto API nazýva \emph{Enterprise Bean-y(EB)}.

EB sa delia na 2 kategórie:
\begin{itemize}
\item Message-driven bean -  Pôsobí v rolu poslucháča  určitý typ správ, na ktorých príjem reaguje vykonaním určitých akcií
\item Session bean - Vykoná úlohy pre klienta.  Môže implementovať webové služby\cite{fitweb}

\end{itemize}


\subsection{Session Bean}\label{sessionkap}
Session bean(SB) je typ EB, ktorá zapúzdruje podnikovú logiku, ktorá môže byť vyvolaná lokálne alebo vzdialene. Prístup k session bean je realizovaný prostredníctvom volania metód SB. SB následne vykoná kód metódy, po prípade vráti nejaký výsledok. \newline \indent SB môže byť 3 typov:
\begin{itemize}
\item Stateful Session Bean - beany udržuje hodnoty premených, každá beana reprezentuje unikátny stav klienta/bean sedenia. Pokiaľ sa sedenie odstrániť stav zmizne.
\item Stateless Session Bean - Neudržuje stav komunikácie s klientom. Počas invokácie metódy takejto beany môže inštancia obsahovať premenné, ktoré môžu obsahovať špecifický stav vzhľadom na klienta, alebo len po počas invokácie metódy. Stav po ukočení mizne, rovnako tento typ SB je možné použiť k implementácií webovej služby.
\item Singleton Session Bean - Teto typ beany je inštanciovaný len raz a pretrváva počass celého životného cyklu aplikácie. Využíva sa pri zdieľaní a súčasnom prístupe viacerých užívateľov.
\end{itemize}

Tento typ beany môžme použiť pokiaľ potrebuje udržať stav medzi klientskými volaniami metód, rovnako pokiaľ potrebuje odľahčiť aplikáciu a zvýšiť výkonnosť použijeme tento typ beany konkrétne stateless session bean. 

\subsection{Message-driven Bean}\label{messagekap}
Message-driven bean(MB) je typ EB, ktorá umožňuje Java EE aplikáciám asynchronné spracovanie správ. Tento beany prijíma Java Messaging Services(JMS) správy z JMS fronty, ktoré následne analyzuje a vykonáva akcie. JMS je technológia, ktorá umožňuje komunikovať komponentám prostredníctvom správ. JMS fronty sú obyčajné fronty, do ktorých sa na jednom konci pri zavolaní MB vloží špecifická JMS správa a na druhej strane je MB postupne tieto správy odoberané a teda spracované len raz. JMS správa prostredníctvom, v ktorých sa prenášajú rôzne informácie(špecifické hodnoty, \ldots). JMS správa môže byť typicky viacerých typov. Správy zaradené v JMS fronte môžu byť poslané rôznymi Java EE komponentami, alebo aj iným systémom, ktorý nepoužíva Java technológiu. Tieto beany nespracovávajú len JMS správy ale aj iné typy správ. Zásadny rozdiel je oproti  session bean v zásade v tom, že sa k takému  typu beanu nepristupuje prostredníctvom rozhrania a invokácie metód. Prístup k takému typu EB sa deje prostredníctvom vytvorenia spojenia s JMS frontou a vložení správou do fronty. Správy sú následne spracované na strane MB metódou \emph{onMessage}, ktorá vyberá z JMS fronty správu po správe. Výhodou MB je ekvivaletnosť MB, to znamená že správy môže EJB kontainer ľubovoľnej inštancii. Klienti pristupujú k message-driven bean, napr. zasielaní správ do cieľa pre message-driven beanu je MessageListener. Message-driven bean má ďalšie zaujímavé vlastnosti a to, že môžu byť vyvolané asychronne,ktoré nevyťažujú tak prostriedky servera, žijú relatívne krátko a sú bezstavové. 



\section{Convetion over Configuration}\label{mavenkap}
Convetion over Configuration je sotwarové paradigma, ktoré zjednodušuje prácu vývojárovi použitím štandardného modelu práce pre všetky projekty. Toto paradigma odľahčuje vývojára od nekonzistentnosti pri vývojou spôsobou nastavovaním rozličných konfiguračných súborov a snaží sa tento prístup zminimalizovať.\newline \indent Jedným z prostriedkom, ktorý implementuje toto paradigma je Maven. Maven je stavebný automatizačný nástroj, ktorý je primárne používaný pre projektu v jazyku Java. Maven definuje spôsob akým bude sotware zostavený, rovnako aj definuje závislosti(Depency Management). Celý obsah je definovaný v XML súbore, v ktorom sa rovnako definujú závislosti na externé moduly, poradie zostavovania komponent a požadované rozšírenia. 
\newline \indent Maven obsahuje predefinované úlohy ako kompilácia, testovanie, balíkovanie a nasadzovanie, ktoré sú štandarnm vývojovým krokom každého projektu. Výhodou tohto nástroja je dynimacké sťahovanie javovských knižníc a rozšírení z jedného alebo viacerých repozitárov(miesto, kde sa nachádzajú java knižnice) ako napr. Maven 2 Central Repository a ukladá ich v lokálnom repozitári na disku. Následne v prípade potreby danej knižnice v projekte sa použije lokálna kópia knižnice pokiaľ je k dispozícií, v opačnom prípade dôjde k jej stiahnutiu. \newline \indent Každý projekt vytváraný pomocou nástroja maven sa konfiguruje XML súboru, ktorý využíva Project Object Model(POM) a nazýva sa pom.xml, pričom sa nachádza v koreňovom adresári projektu. POM je XML súbor s konfiguráciami projektu, závislosti a inými informáciami o projekte. Každý Maven projekt spĺňa štandardnú adresárovú štruktúru.

\begin{figure}[htb]

\begin{center}

\includegraphics[scale=0.5]{maven.jpg} 
\caption{Maven adresárová štruktúra  prevzaté z [http://maven.apache.org/] }
\label{maven}

\end{center}

\end{figure}
obrázok č. \ref{maven} ukazuje základnú adresárovú štruktúru maven projektu. Každý maven projekty sa skladá z project home, ktorý obsahuje súbor pom.xm a všetky ostatné podadresáre. Ďalej sa skladá z priečinkov src, kde sa nachádzajú zdrojové kódy a target, kde sa ukladajú preložené triedy\cite{mavenbook}. Adresár src sa ďalej skladá z adresáru main, ktorý ešte obsahuje adresára java, ktorý obsahuje java zdrojový kód pre daný projekt a resources, ktorý obsahuje prostriedky pre daný projekt ako sú rôzne súbore, ktoré obsahujú nastavenie prostriedkov pre daný projekt. Podadresár src sa skladá z adresára test, ktorý rovnako ako src obsahuje podadresár java, korom je umiestnený java zdrojový kód pre testovanie projektu. Podadresár test obsahuje ďalší adresár resources, ktorý obsahuje prostriedky potrebné pre testovanie. Celá táto štruktúra predstavuje základne adresáru štruktúru pre maven projekt a tak to robí viac prenositeľný. Jednotlivé závislosti pre projekt jednoducho definuje v súbore pom.xml. Preložením projektu sa preložia všetky triedy a uložia do adresára tagert. Celý projekt môže byť pre väčsiu modularitu rozdelený na moduly, pričom každý modul rovnako splňuje základnú Maven adresárovú štruktúru. Každý maven projekt je možné dať ako cieľ jednú z fázy životného cyklu. Životný cyklus môže byť z jednej fáz: 1. validate - validácia korektnosti projektu a kontrola dostupnosti potrebných informácií pre projekt ,2.kompilácia - kompilácia zdrojového kódu projektu, 3.test - testovanie zkompilovaného zdrojového kódu, táto fáza nie je vyžadovaná 4.package - zabalenie zkompilovaného projektu do balíku, napríklad jar, 4. integration-test - spracovanie a nasadenie balíku pokiaľ je to potrebné do prostredia, kde môžu bežať integračné testy, 5.verify-run - beh a overenie balíku, že spĺňa všetky kritéria pre spustenie, 6. install - inštalácia balíku do lokálneho repozitára, v prípade, že potrebuje použiť balík ako závislosť 8.deploy - nasadenie projektu do kontejneru a spustenie.
Jednotlivé fázy môže spustiť príkazom \uv{mvn názov životného cyklu}, napríklad mvn package.

\section{Twitter Bootstrap}\label{bootkap}
Twitter Bootstrapje je dostupný súbor nástrojov pre vytváranie moderného webu a webových aplikácií\cite{boot.} Ponúka podporu najrôznejších webových technológií HTML, CSS, JavaScript a mnoho prvkov, ktoré je možné ľahko implementovať do svojej stránky. Boostrap implementuje interaktívne prvky ako sú tlačidlá, boxy , menu a ďalšie grafické elementy. Pre použitie Boostrap-u je potrebné vložiť do HTML kódu odkaz  na stiahnuté kaskádové štýly a javascriptový súbor.

Výhodou týhto nástrojov je jednoduché je jeho jednoduché používanie a možnosť použitia aj na mobilných telefónoch. Podrobné vysvetlenie jednotlivých komponent nájdete na nasledujúcej adrese http://getbootstrap.com/, rovnako aj s príkladmi použitia. 

Boostrap obsahuje rozšírenie Font Awesome\ref{fontkap}, čo je CSS framework, ktorý obsahuje rôzne grafické ikony, ktoré je možné intregovať do HTML kódu.


\section{Rich Faces}\label{richkap}
Rich faces je open-source framework s podporou Asynchrouns Javavascript and XML(AJAX)\cite{ajaxbook}, ktorý predstavuje rozšírenie JSF frameworku\cite{jsfkap}. Rich Faces obsahuje API, ktoré obsahuje grafické komponenty s podporou Ajax-u. Rich Faces je možné ľahko integrovať pomocou nástroja  maven\cite{mavenkap}. RichFaces podporuje množstvo preddefinovaných vzhľadov. Rovnako umožňuje definovať, ktoré JSF komponenty budú invokované na základe Ajax požiadavky, vrátane spôsobu invokácie a odpovede. Rovnako podporuje validáciu na strane klientského prehliadača. Rovnako sa MySQL technológia snaží pri vykonávaní transakcií dotazy optimalizovať.


\section{MySQL}\label{mysqlkap}
MySQL je databázová technológia, ktorá je vhodná pre malé a stredne veľke aplikácie, rovnako poskytuje dobrý výkon pri vykonávaní transakcíí. Umožňuje vytvárať procedúry, databázové triggere a jej inštalácia je pomerne jednoduchá a nezaberá veľa diskové priestoru, rovnako je MySQL multiplaformová, keďže je možné ju nasadiť na systémy s operačným systémov Windows, Linux, Mac Os. Medzi nevýhody tejto technológie patrí neefektívna práca s databázovými transakciami, neefektívne ukladanie veľkého množstva dát. MySQL je open source a je vyvíjaná spoločnosťou Sun Microsystems.

\section{Seam}\label{seamkap}
Na zabezpečenie Java EE aplikácie bol vybratý open-source framework Seam\cite{seambook}. Seam je aplikačný framework pre enterprise Javu, ktorý definuje uniformný komponentný model pre podnikovú logiku aplikácie. Seam rieši integráciu EJB\ref{ejbkap} a JSF\ref{jsfkap} spolu. Medzi ďalšie výhodné vlastnosti tohto frameworku patrí intergrácia Asynchronous JavaScript and XML(Ajax)\cite{ajaxbook}, rovnako aj vstavaná podpora javascriptu a efektívne spracovanie webových dotazov. \newline \indent My sa zameriame na modul Seam security, ktorý obsahuje množstvo mechanizmov na zabezpečenie našej enterprise aplikácie. Základom každej bezpečnosti je autentifikácia, čo je process vytvorenia alebo potvrdenia identity užívateľa. Užívateľ potvrdzuje svoju identitu prostredníctvom užívateľského meno a hesla. Seam security poskytuje API prostredníctvom, ktorého je možné sa autentizovať z rozličných zdrojov(databáze, \ldots). Ďalšou vlastnosťou je Identity Management, ktoré je množina API na správu užívateľov, skupín a užívateľských rol. Identity Managent je poskytovaný v Seam komponentou PicketLink IDM, ktorá spravuje uloženie užívateľov v rozličných bezpečnostných úložiskách. Seam security je k dispozícií v prostredníctvom nástroja Maven. \newline \indent Základom autentifikácie je Identity Bean, čo je java trieda, ktorá reprezentuje identitu užívateľa a pri úspešnej autifikácií je identita je vložená do životného cyklu aktuálneho sedenia. V rámci autentifikácie sú definované metódy \emph{Login(prihlásenie)} a \emph{Logout(odhlásenie)}. Základom každej triedy, ktorá realizuje autentifikáciu je metóda, v ktorej prebieha autentifikácia uźívateľa.
Počas autentifikácia sa overí pravosť užívateľa a v metóde authenticate sa prostredníctvom metódy \emph{setStatus}  nastaví úspech(SUCESS) alebo neúspech(FAILURE) pri overení zadaných údajov. Po autentifikácií dôjde k vloženiu identity do životného cyklu užívateľa, ktorú je možné získať z triedy triedy prostredníctvom anotácie @Inject triedy Identity. \newline \indent Seam security modul poskytuje spôsob akým zabezpečiť svoje triedy a metódy prostredníctvom anotácií tohto API.
\newline \indent Ďalší modul, ktorý nás zaujíma je Seam Faces, ktorý obsahuje API na zabezpečenie prístupu k HTML a XHTML stránkám. Túto fukčnosť nazývame \emph{Faces View Configuration}, ktorá nám umožňuje spojenie so Seam Security modulom na obmedzenie/povolenie prístupu pre danú užívateľskú rolu, preprepisovanie URL, k HTML/XHTML stránkam \ldots. HTML/XHTML stránky sú anotované prostredníctvom špeciálnych vlastností a umiestnené vo java triede, ktorá obsahuje výčte. Trieda je anotovaná tagom @ViewConfig. Vo výčte sú obsiahnuté anotácie na obmedzenie prístupu k HTML/XHTML stránkam. Základom  obmedzenia prístupu je tvorba rozhraní, ktoré obsahujú autorizačné metódy, ktoré overujú identity daného užívateľa. Názvy týchto rozhraní použijeme ako anotácie vo výčte, kde každej stránke pridružíme názov rozhrania(overujúce identitu užívateľa), ktorému priradíme anotáciu @ViewPattern(), ktorá obsahuje názov XHTML/HTML stránky, ktorej je prístup povolený. Vytvorením viacerých stránok a rozhraní a následnou anotáciou môžme sprístupniť časti systému rôznym užívateľom. V tomto výčte je rovnako definovaný postup pri neautorizovanom prístup k stránke. Uvedením tagu @AccessDeniedView, do ktorého parametru vložíme názov stránky, na ktorú bude neautorizovaný užívateľ presmerovaní, k anotácií @ViewPattern, hovoríme ako sa má zachovať v prípade, že o danú stránku zažiada užívateľ bez potrebných oprávnení. Seam framework patrí pod divíziu JBoss, takže je pomerne jednoduché ho intergrovať pod aplikačný server JBoss-u. 


\section{Testovanie}
V poslednom rade uvedieme technológie, ktoré budeme používať pre testovanie výslednej aplikácie. Základom testovania je nástroj JUnit a nástroj Arqullian.
V prvom rade sa budem venovať nástroju JUnit. JUnit je unit testovací nástroj pre programovací jazyk Java. JUnit sa používa pre typ testovania, ktorý sa nazýva \uv{test-driven development}\cite{testdevbook} a je jedným z kolekcie unit testovacích nástrojov. JUnit býva súčaštou balíku org.junit\cite{junitbook}. Testovacie metódy sú anotované prostredníctvom @Test anotácie. JUnit rovnako umožňuje vykonať kód pred spustením testu, to docielime anotovaním metód @Before anotáciou alebo po sputení testu, to docielime anotáciou @After. V testovacej metóde potom vykonáme nejaké kód a očakávaný výstup porovnáme s nami očakávaným výsledok prostredníctvom metódy \emph{Assert}. JUnit testy sú písané pre otestovanie konkrétnej funkčnosti kódu. Cieľom testovania prostredníctvom JUnit sú malé kúsky kódu, ako metódy alebo triedy. 
\newline \indent Nakoniec spomeniem nástroj Arquallian. Arquallian je testovací nástroj, ktorý vykonáva testy vo vnútri vzdialeného alebo vstavaného kontajneru alebo nasadí archív(obsahujúci java triedy spolu s testovacími trieda) na Java EE kontajner. Arquallian integruje aj ďalšie testovacie nástroja, napr. JUnit 4, TestNG 5, \ldots. Treba zdôrazniť, že narozdiel od JUnit testov umožňuje testovanie v java EE kontajnery(GlassFish, JBoss)\cite{arqbook}. Tento framework má zásadnú výhodu v prenositeľnosti testov na rôzne podporované Java EE kotajnery. Nástroj pri spustení automaticky zabalí do archívu všetky potrebné prostriedky pre platformu. 
\newline \indent Použitie Arqullian sa deje použitím anotácie @RunWith Arquillian v našej javovskej testovej triede, ktoré zabezpečí spustenie testov. Následne tento nástroj sputí kontajner a nasadí testovací archív, ktorý je daný anotáciou @Deployment. Archív obsahuje testy so špecickými triedami a knižnicami. Testy sa následne vykonajú vo vnútri kotajneru. Čo znamená, že môže použiť otestovať podnikové a webové komponenty za behu. Písanie testo s nástrojou Arqullian začína tvorbou javovskej triedy, ktorá vyzerá ako štandardná testovacia trieda vytvorená nástrojom JUnit, pričom obsahuje vyššie spomenuté špecifické anotácie, ktoré umožňujú pri spustení testu vytvorenie archívu, nasadenie na Java EE kontajner a následne spustenie testov.  Aby tento nástroj mohol byť použitý je nutné mať k dispozícií všetky potrebné prostriedky(knižnice), ktoré môžme získať prostredníctvom nástroja maven a následne je potrebné nakonfigurovať v XML súbore arquillian.xml použitie Java EE kontajnera. Arquallian.xml je xml súbor, ktorý použitie Java EE kontajneru a ďalšie špecifické vlasnosti.


\section{WildFly Aplikačný server}\label{jbossc}
Aplikačný server(AS) je sotware, ktorý poskytuje vrstvu medzi operačným systémom a Java EE aplikáciami. AS poskytuje základnú funkcionalitu aplikáciám(prístup k súborovému systému, posielanie správ, \ldots), konkrétne enterprise aplikáciám. Vytvára vrstvu, ktorá zjednodušuje vývoj enterprise aplikácie. Dôvod použitia pre enterprise aplikácie je ten, že tieto aplikácie sú robustné a komplexné a spracovávajú súčasne veľké množstvo požiadavkou od klientov, pričom typickou aplikáciou môže byť webová aplikácia. Pomerne veľká skupina AS je vyvíjaná v jazyku Java. Dôvodom pre tento jazyk existencia štandardu pre enterprise aplikácie a to je Java EE.

WildFly je open-source aplikačný server verzie 8, ktorý vznikol premenovaním aplikačného serveru JBoss, čo je vlastne skratka pre JavaBeans Open Source Applicatom Server. Pre naše potreby budeme používať WildFly v verzii 7, preto bude používaný názov JBoss. JBoss je aplikačný server, ktorý je založený na platforme Java a Java Enterprise Edition.\cite{jbossbook}. Tento typ AS je open-source, preto je možné jeho stiahnutie spolu so zdrojovými kódmi. Používanie aplikačného servera JBoss je veľmi jednoduché jeho spustenie môžte vykonať ručne prostredníctvom konzole a nájdeným inštalačného adresára JBoss-u a následne adresára bin, ktorý obsahuje skript run.sh, ktorý spustí AS. Druhou možnoštou je spustenie prostredníctvom IDE. Po spustení serveru je možné k nemu implicitne pristupovať na localhost na porte 8080 počítača. Základným stavebným kameňom JBoss AS je JBoss Microcontainer. JBoss Microcontaijner je refaktorizácia JBoss JMX Microkernel aby podporoval POJO nasadzovanie a samostatné použitie mimo aplikačného servera. Microcontainer plní funkciu jadra, do ktorého sa registrujú všetky služby. Služby, ktoré majú by prístupné sa registrujú v podobe managed beans. Microcontainer spravuje a riadi beh týchto služieb. Prostredníctvom rozhrania Java Management Extension je možné tento server spravovať. JBoss implicitne podporuje databázový server Hypersonic SQL, ktorý má ale obmedzené možnosti a preto je určený len na testovanie. JBoss je licensovaný pod GNU Lesser General Public License(GNU PL).


\chapter{OptaPlanner}\label{optaplannerC}
OptaPlanner je open source framework a prokračovanie frameworku JBoss Drools, ktorý vykonáva a optimalizuje rôzne plánovacie problémy, ktoré sú reprezentované XML súborom, s rozličným stupňom náročnosti. Optaplanner využíva pri riešení problému, ktoré nemusí vždy nájsť, optimalizačné heuristiky a metaheuristické metódy s využitím skóre. Skóre je hodnota, ktorá reprezentuje bodové hodnotenie optimálnosti dosiahnutého riešenia. Výsledným riešením je to riešenie, ktoré má najvyššie skóre. Tento framework neurčuje striktne akými algoritmami a metódami sa má daný problém vyriešiť, ale konfiguráciu ponecháva na strane užívateľa. OptaPlanner je určený pre jazyk Java, preto riešenie je vykonávané triedami v tomto jazyky. Tieto triedu sú špecifické pre daný problém, a musia byť schopné získať potrebné informácie z defičného súboru problému, ktorý reprezentuje zadanie problému, musia byť schopné vykonávať postupné kroky vedúce k riešeniu problému(napr. v prípade problému N Dám presúvať dámy, tak aby sa vždy nachádzali vo validných pozíciách) a prostriedky, ktoré ohodnotnia krok a pričítajú ho ku celkovému skóre. \newline \indent Samozrejme postup riešenia problému, kalkulácií skóre sa opakuje pre rôzne scenáre(napr. v prípade N Dám pre rôzne kombinácie pohybov) a vráti sa riešenie s najlepším skóre v podobe súboru vo formáte XML(napr. v prípade riešenia problému N Dám poskytne najlepšie možné riešenie). OptaPlanner sa snaží vždy nájsť optimálne riešenie vzhľadom k optimalizačným algoritmom a metaheurestickým metódom a dostupnému času, ale niekedy nie je schopný poskytnúť na predchádzajúce podmienky optimálne riešenie. Výhodou tohto frameworku je možnosť aplikovania na NP-úplne problémy. OptaPlanner je dostupný prostredníctvom nástroja Maven.

\section{Plánovací problém}\label{planprob}
Plánovacím problémom môžme obecne rozumieť akýkoľvek problém, ktorý vyžaduje od nás zdroje a predikciu na priradenie zdrojov, nájdenie riešenia takého, abý výsledok bol v konečnom dôsledku najlepší, cenovo najprijatelnejší aj časovo najprijatelnejší.

V bežnom živote, rovnako ako ja v podnikových sférách sa stretávame s rôznymi plánovacími problémami. Môže ísť o problémy ako správne naplánovať cestu vozidiel(aút, lodí,\ldots), aby sme ju spravili za čo najkratší čas, rovnako môžme požadovať aby cesta bola, čo finančne najefektívnejšia. Rovnako môžme plánovanie rozvrhu práce zamestatnancov vo firme, aby zbytočne nespomalovali chod a ostatních zamestatnci, ktorí sú na ich práci závislí nemuseli zbytočne čakať. Plánovať môžme spúšťanie testovania aplikácií v rámci vývojarskej firmy, aby niektoré úlohy boli otestované skôr ako iné no musí byť čo najefektívnejšie vývažené a zbytočne nemrhali časovým kvantom. Pokiaľ je problém dostatočne komplexný potom je veľmi vhodné použiť Optaplanner. 
\newpage
\begin{figure}[htb]

\begin{center}

\includegraphics[scale=0.7]{fig/useCaseOverview.jpg} 
\caption{Problém rozvrhnutia práce, prevzaté z [http://www.optaplanner.org/]. }
\label{obrazokUseCase}

\end{center}

\end{figure}
Obrázok č. \ref{obrazokUseCase} zobrazuje typické použitie OptaPlanner-u. Môžme vidieť v nasledujúcom obrázku vystupú 4 osoby(označené obdĺžnikom modrej, žltej, zelenej a oranžovej farby), ktoré vykonávajú nejakú činnosť. Ich činnosť je špecifická a silne závisí od práce predchádzajúcich. V prípade náročnosť zadania takého problému je pomerne jednoduché naplánovať správne poradie činností. Problém nastáva, ak by v danom obrázku bolo niekoľko násobne viac ôsob. V tomto prípade štandardným prístupom by mohlo dôsť k neefektívnemu rozdelnie práce a k zbytočnému mrhaniu času. Preto je vhodné použiť OptaPlanner, ktorý sas naží ich činnosti maximálne optimalizovať a jednotlivé činnosti zvoliť v následnosti tak, aby výsledná práca bola spravená za najkratší možný čas vzhľadom na činnosť, ktorá sa optimalizuje.

Definícia problému v prirodzenom jazyku by mohla v oblasti informačných technológií spôsobiť nejednoznačnosť v jej interpretácií, preto je používaný súbor vo formáte XML, v ktorom definujeme počiatočné zadanie problému. Formát XML súboru závisí od zadania problému. V prípade, že si zobere problém N Dám, tak zadanie súboru obsahuje presnú pozíciu dám na šachovnici. Keď si zobereme problém obchodného cestujúceho, tak definičný XML súbor obsahuje zoznam miest a jednotlivé vzdialenosti od seba. Obsah definičného súboru nemôže nemá jednoznačný formát, ale vždy závisí od plánovacieho problému.


\section{Výsledky plánovacieho problému}

Niektoré problémy môžu obsahovať aj pozitívne podmienky alebo odmeny, ktoré by mali byť splnené pokiaľ je možné ich splniť.




OptaPlanner podporuje niekoľko optimalizačných algoritmov ako efektívne nájsť tieto veľké množstvá riešení. V závislosti na prípade použitia, niektoré optimalizačné algoritmy dosahujú lepšie výsledky ako ostatné, ale to je nemožné povedať dopredu. Pri plánovaní, je ľahké prepnúť algoritmus optimalizácie, zmenou konfigurácie Solver-u.



\section{Princíp}
Princíp riešenia problému je založené na konfigurácií OptaPlanner tvorbou javovských tried na získanie potrebných dát z definičného súboru, prostriedkov na kalkuláciu skóre a aplikáciu odkiaľ spúšťami výpočet. Riešenie problémom sa začína tvorou XML definičného problému špecifického pre daný problém. Následne sa vytvoria triedy pre získanie dát z XML súboru, triedy pre vykonávanie krokov(napr. v prípade N dám presúvanie dám na validné pozicie) a prostriedky pre kalkuláciu skóre a nastavenie konfiguračného súboru pre daný problém, ktorý bude bližšie popísaný v nasledujúcej kapitole\ref{confopt}. Aby bolo jasné aké akcie sú povolené pre daný problém sú definované v triedach pre riešenie obmedzenia:
\cite{optabook}
\begin{itemize}
\item Negatívne "hard" obmedzenie, ktoré nesmú byť porušené\label{hardobm}
\item Negatívne "soft" obmedzenie, ktoré by nemali byť porušené pokiaľ sa dá tomu vyhnúť.
\item Pozitívne "soft" obmedzenia, ktoré by mali splnené pokiaľ je to možné(môžu viesť k lepšiemu skóre)
\end{itemize}

 Prostriedky pre kalkulácie skôre môžu byť 3 typov:
\begin{itemize}\label{skorkal}
\item Jednoduchá kalkulácie skóre 1 metódou
\item Inkrementálna kalkulácie skóre prostredníctvom viacerých metód
\item Drools kalkulácia skore - táto konfigurácia definuje pravidlá pre kalkulovanie skóre\label{drollskal}
\end{itemize}
Drools kalkulácia skóre využíva vlastnú DRL syntax a je daná súborom, ktorý obsahuje pravidlá. Každé pravidlo je dané svojim názvom a podmienkou, v ktorej sa overuje priebežné riešenie problému(napr. v prípade N Dám priebežné rozloženie dám), ktorá v prípade splnenia upravuje skóre. Treba zdôrazniť, že v konfiguračnom súbore užívateľ nastavuje optimalizačné algoritmy a metaheuristické metódy, ktorý sa snažia v spolupráci s triedami na riešenie vyberať vždy najlepšie kroky pri riešení.

 Spustenie riešenia je dané zavolaním hlavnej metódy odkiaľ sa spúšťa riešenie problému. 
a spustí vykonávanie(plánovanie). Postup je nasledovný:
\begin{enumerate}
\item Overenie prostriedkov(definičného súboru, konfiguračného súboru(spôsob kalkulácie, definičného triedy, použitie plánovacích algoritmy a metaheurestických metód) a prostriedkov na kalkuláciu skóre)
\item Načítanie sa obsah XML súboru 
\item Vykonanie kroku podľa použitia plánovacích algoritmov
\item Optimalizácia kroku v prípade použitia metaheuristických metód
\item Ohodnotenie kroku(v závislosti od použitia prostriedkov na kalkuláciu skóre\ref{skorkal})
\item Vykonanie alternatívneho kroku vzhľadom(napr. v prípade N Dám presunutie dámy na ľavú stranu šachovnice, miesto pravej)
\item Optimalizácia alternatívneho kroku v prípade použitia metaheuristických metód
\item Ohodnotenie kroku(v závislosti od použitia prostriedkov na kalkuláciu skóre\ref{skorkal})
\item Opakovanie krokov 3., 4., 5., 6. až dokým nie je dosiahnuté riešenie alebo plánovanie nie je predčasne ukončené
\item Nájdenie riešenia alebo predčasné ukončenie plánovanie vzhľadom na vysoké poskytnuté skóre(je možné použiť v prípade, že riešenie problému vzhľadom na dostupný čas a použitie plánovacích algoritmov nebolo nájdené)

\end{enumerate}

\newpage
\section{Konfiguráciu OptaPlanneru}\label{confopt}
Konfigurácia OptaPlanner sa realizuje prostredníctvom XML súboru, ktorá má 3 povinné časti a 4. voliteĺnú. Pre lepšiu prehľadnosť je uvedená ukážka konfiguračného súboru. 
 \lstset{
    language=xml,
    tabsize=3,
    %frame=lines,
    caption=Vyváženie cloudu,
    label=code:sample,
    frame=shadowbox,
    rulesepcolor=\color{gray},
    xleftmargin=20pt,
    framexleftmargin=15pt,
    keywordstyle=\color{blue}\bf,
    commentstyle=\color{OliveGreen},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    showstringspaces=false,
    basicstyle=\footnotesize,
    emph={food,name,price},emphstyle={\color{magenta}}}
    \lstinputlisting{cloudBalancingSolverConfig.xml}

\newpage
Nastavenie konfiguračného súboru(solver) pre riešenie problému vyváženie cloudu pozostáva z 3 častí: 
\begin{itemize}
\item Nastavania definičných tried plánovacie problému, nastavania tried zabezpečujúce plánovanie, nastavenie definícií skóre a nastavenie použitia plánovacích algoritmov, po prípade nastavenia metaheurestických metód
\item Súbor je rozdelený na 3 časti:
\begin{itemize}
\item Domain model configuration(začínajúc riadkom č.4), v ktorom sú uvedené triedy definujúce problém a riešenie
\item Score Configuration(začínajúc riadkom č.7) definujúce spôsob kalkulácie skóre vrátane triedy
\item Optimalization algorithms configuration(začínajúc riadkom č.13) sú uvedené optimalizačné algoritmy, vrátane spôsobu ukončenia plánovia
\end{itemize}
\item Na riadku č.3 uvedená medzi značkami \epmh{enviromentMode} hodnota \uv{FAST_ASSERT}, ktorá umožňuje OptaPlanner detekovať chyby v implementácií
\item Na riadku č.5 je uvedená medzi značkami \emph{solutionClass} hodnota \uv{org.optaplanner.examples.cloudbalancing.domain.CloudBalance}, ktorá odkazuje na definičnú triedu modelu problému vyváženie cloudu
\item Na riadku č.6 je uvedená medzi značkami \emph{planningEntityClass} hodnota \uv{org.optaplanner.examples.cloudbalancing.domain.CloudProcess}, ktorá odkazuje na triedu, ktorá realizuje riešenie(plánovanie) problému
\item Na riadku č.9 je uvedená medzi značkami  \emph{scoreDefinition} hodnota \uv{HARD_SOFT}, ktorá hovorí, že pri kalkulácií skóre použijeme len hard obmedzenia\ref{hardobm}
\item na riadku č.10 je uvedená medzi značkami \emph{simpleScoreCalculatorClass} hodnota \uv{org.optaplanner.examples.cloudbalancing.solver.score.CloudBalancingSimpleScoreCalculator}, ktorá odkazuje na trieda, ktorá kalkuluje skóre pri riešení problému
\item Na riadku č.11 je uvedená medzi značkami \emph{scoreDrl} hodnot \uv{/org/optaplanner/examples/cloudbalancing/solver/cloudBalancingScoreRules.drl}, ktorá odkazuje na Drools definicíciu kalkulácie skóre\ref{drollskal}
\item na riadku č.15 je uvedená medzi značkami \emph{maximumSecondsSpend} hodnota \uv{120}, ktorá hovorí, že riešenie musí byť nájdené do 120 sekúnd v opačnom prípade dôjde k ukončeniu riešeniu a vrátenia najlepšieho doposiaľ dosiahnutého riešenia
\item Na riadku č.18 je uvedená medzi značkami \emph{constructionHeuresticType} hodnota \uv{FIRST_FIT?DECREASING}, ktorá označuje použitie plánovacieho algoritmu FIRST_FIT_DECREASING\cite{algibook}
\end{itemize}
\item Na riadku č. 20 je uvedená medzi značkami \emph{pickEarlyType} hodnota \uv{FIRST_NON_DETERIORATING_SCORE}, ktorá označuje použitie pri kalkulovaní skóre najprv nezhoršujúce sa skóre(ohodnotenie, ktoré zvyšuje hodnotu celkového skóre)
\item Na riadku č. 25 je uvedená medzi značkami \emph{entityTabuSize} hodnota \uv{entityTabuSize}, ktorá značí použitie metaheuristickej metódy pri riešení TABU SEARCH\cite{algibook}, s veľkosťou tabuľky 7
\item Na riadku č. 28 je uvedená medzi značkami \emhp{acceptedCoundLimit} hodnota \uv{1000}, ktorá označuje počet náhodných krokov, ktoré sú vyhodnotené počas 1 kroku riešenia problému



\newpage


\chapter{Aplikácia}\label{impl}
V tejto kapitole postupne uvedieme požiadavky na aplikáciu, analýzu systému, návrh aplikácie, implementáciu, testovanie a nakoniec vyhodnotíme aplikáciu a navrhneme jej možné rozšírenia.

\section{Špecifikácia požiadavkov}
V tejto kapitole postupne rozobereme požiadavky na systém monitorovania úloh. Základnou úloh systému je monitorovanie úloh. Na jednej strane bude systém schopný zobrazovať stav plánovacích úloh, na druhej stranej bude môcť systém plánovacie úloh spúšťat/pozastaviť. Úlohy bude možné triediť podla určitého kritéria, rovnako systém bude schopný aj úlohy vyȟladávať. Jednotlivé úlohy je možné aj mazať, alebo zmeniť definíciu plánovacieho problému\ref{planprob} a úlohu znovu spustiť. Novú úlohu bude možné do systému vložiť a následne sputiť. Úlohy bude môcť systém publikovať, čo sa myslí akcia, ktorá vytvorý pre úlohu špeciálne URL, na ktoré po kliknutí zobrazí stránku z názvom úlohy a obsahom XML definičného súboru. Úlohu bude možné aj odpublikovať.
 Systém bude rozdelený podľa užívateľ do 3 užívateľských rolí(Administrátor, Plánovač, Čitateľ). Užívatelia sú organizované do väčších celkov(organizácie). Preto systém bude schopný spravovať užívateľov,rovnako aj spravovať organizácie, ktoré bude schopný prehľadne zobrazovať, triediť a vyhľadávať podľa určitého kritéria. Užívateľov a organizácie je možné vytvárať. Užívateľ si bude môcť ľubovoľne meniť heslo v systéme. Vytvorený užívatelia sa do systému prihlasuje, pričom po prihlásení je sprístupnená len časť systému podľa užívateľskej role prihláseného užívateľa. Aplikácia bude obsahovať bezpečnostné mechanizmy, ktoré zabezpečujú aplikáciu proti neautorizovanému prístup úžívateľov. Vstupmi do systému budú:\begin{itemize}
\item Definičný súbor plánovacieho problému
\item Užívatelia systému, ktorý vykonávajú akcie v systéme
\item Organizácie, do ktorých sú začleňovaný užívatelia
\end{itemize}
Výstupom systému je zoznam plánovacích úloh v prehľadnej tabuľke, rovnako aj zoznam užívateľov a organizácií, ktoré sa rovnako zobrazujú v prehľadnej tabuľke. V predposlednom rade treba spomenúť, že výslednej rozhrania bude schopné byť prenositeľné na mobilné telefóny. 

V poslednom rade treba uviesť rozsah úloh, ktoré bude môcť každá užívateľská vykonávať:
\begin{itemize}
\item Administrátor - má prístup ku všetkým úlohám v systéme, úlohy môže editovať vytvárať, mazať, publikovať a odpublikovať , môže vytvárať, mazať a editovať užívateľov, rovnaké môžnosti má aj s organizáciami
\item Plánovač - má prístup k úlohám v rámci svojej organizácie, môže vytvárať, editovať, mazať úlohy, publikovať a odpublikovať
\item Čitateľ - úlohy môže len zobrať v rámci svojej organizácie, publikovať , odpublikovať
\end{itemize}

Poslednom podmienkou bolo zvoliť vhodný prístup k databáze, ktorý by bol univerzálny a teda nezávislý na použitej databázovej technológií.

\section{Analýza}
Výslednú aplikáciu môžme rozdeliť na 2 časti: 1. backend aplikácie, ktorý beží na Java EE serveri JBoss 2.frontend aplikácie grafické užívateľské rozhranie. Zameriame sa najprv na grafické užívateľské rozhranie. Pri analýze grafického užívateľského rozhrania je potrebné vyriešiť problém jeho návrhu a možnosti jeho interakcie. Použitie technológie JSP\ref{jspkap} by síce pripadalo do úvahy, problém je že táto technológia neposkytuje žiadne grafické komponenty a jeho interakcia s inými komponentami je pomerne komplikovaná. Z tohto dôvodu bola použitá technológia JSF\ref{jsfkap}, ktorá spĺňa túto podmienku. Jej výhodou je jednoduchá integrácia s aplikačným serverom JBoss. Problémom, ktoré užívateľské rozhranie potrebuje vyriešiť je pravidlné obnovovanie obsahu tabuliek plánovacích úloh, organizácií a užívateľov, ktoré prostredníctvom technológia je pomerne málo konfigurovateľné. Lepšie riešenie poskytuje použitie frameworku Rich Faces\ref{richkap}, ktorý priamo integruje Ajax\cite{ajaxbook}, do všetkých jeho kompotent. Posledným problémom, ktorý treba pri analýze grafického užívateľského rozhrania vyriešiť je prenositeľnosť na mobilné zaradenia. V tom nám pomôže framework Twitter Boostrap\label{bootkap}. Prenositeľnosť je možná na mobilné rozhrania disponujúce ľubovoľne veľkou zobrazovacou jednotkou. Treba ale zdôrazniť, na ktorých webových prehliadačoch je možné aplikáciu bez problémov prehliadať:
\begin{itemize}
\item Na systéme Android: Chrome, Firefox
\item iOS: Chrome, Safari
\item Mac OS X: Chrome, Firefox, Opera, Safari
\item Windows: Chrome, Firefox, Internet Explorer(verzia 8 - 11), Opera, Safari
\item Linux: Chromium, Firefox
\end{itemize}
Tento framework sa vždy snaží podporovať najnovšie verzie všetkých vyššie uvedených prehliadačov. Podpora ostatných prehliadačov nie je odporúčaná z dôvodu neočakávaného chovania. Ako rozšírenie bol použitý CSS framework Font Awesome\ref{fontkap}, ktorý obohacuje rozhranie o grafické ikony.

V druhej časti sa zameriame na problémy backend-u aplikácie. Celá aplikácie potrebuje udržovať a spravovať dáta. Dáta je sú mienené informácie o úlohách, užívateľoch a organizáciach. Z toho dôvodu bolo treba vyriešiť otázku voľby vhodnej databázovej technológie. Existuje niekoľko možností, ktoré sa dajú ľahko integrovať s Jboss-om\ref{jbossc}. Keďže nároky na vyťaženosť prístupu k dátam, rovnako aj množstvo uložených dát sú malého merítka bolo vhodné vzoliť k tomu adekvátnu databázou technológiu a tou technógiu je MySQL\ref{mysqlkap}. Následne treba spomenúť problém komunikácie s grafickým užívateľským rozhraní. Grafické užívateľské rozhranie potrebuje komunikovať s databázou odkiaľ získava aktuálne informácie o úlohách, užívateľoch a organizáciách. Rovnako sa do databáze zapisujú priebežné informácie o plánovaní. Vzhľadom na podmienku nezávislosti použitia databázovej technológie bola použitá technológia JPA\ref{jpakap}. Rovnaký prístup k databáze využíva aj OptaPlanner. Užívateľské rozhranie je schopný spúšťať plánovanie systému OptaPlanner, ktoré je optimalizované pre riešenie problému N Dám. K tomuto rozhraniu je pristupované prostredníctvom webovej služby\ref{webkap} prostredníctvom HTTP protokolu. Z dôvodu použitia štandardných komunikačných protokolov a nižším nákladom na prevádzkovenie bola zvolená \uv{Big} webová služba\ref{bigkap}. Užívateľské rozhranie predstavuje klienta, ktorý volá metódy na spustenie a pozastavenie výpočtu. OptaPlanner obsahuje koncový bod, ktorý zachytáva správy od klienta a zabezpečuje spúštanie/pozastavenie výpočtu(plánovania). Výsledné užívateľské rozhranie bolo potrebné zabezpečiť voči neautorizovanému prístupu. Existuje priamo zabezpečiť aplikáciu pomocou štandardného API Java EE, no bol zvolený framework Seam\ref{seamkap}, ktorý možno jednoducho integrovať pod JBoss.

Koncový bod webovej služby je reprezentovaný v podobe session bean-y\ref{sessionkap}, ktorá obsahuje funkčnosť pre spustenie a zastavenie výpočtu. Pri spustení výpočtu sú informácie predávanie message-driven bean\ref{messagekap}, ktorá zabezpečuje spúštanie plánovania prostredníctvom OptaPlanner-u\ref{optaplannerC}.


\section{Návrh aplikácie}
Výsledná aplikácia je rozdelená na 2 časti. Na časť reprezentujúci grafického užívateľského rozhranie s podporou prihlasovanie a užívateľských rol, zabezpečenia proti neautorizovanému prístupu. Rovnako je schopné zobrazovať úlohy, užívateľov a organizácie podľa užívateľskej role. Rozhranie pravidelne aktualizuje informácia o úlohach, užívateľoch a organizáciach z databáze. Pre spustenie výpočtu úlohy komunikuje pomocou webovej služby s \uv{PlannerService}(optimalizovaná pre riešenie problému N Dám), ktorá implementuje spracovanie informácií. Pri požiadavke o spustenie/pozastavenie výpočtu spracovania úlohy sa predá v HTTP požiadavky ID úlohy. Webová služba následne zaradí požiadavok o spustení do jms fronty. Message-driven bean-a následne postupne odoberá požiadavky z fronty a vyhodnocuje. Pritom najprv nájde potrebný XML definičný súbor v databáze a spustí výpočet pomocou OptaPlanner. Priebežné informácie(čas do skončenia plánovania, pokrok vo výpočte) sú priebežne vkladané do databáze, čo umožňuje užívateľovi prostredníctvom rozhrania sledovať stav úlohy. Pozastavenie úlohy dôjde prostredníctvom zmeny stavu vo webovej službe, čo pozastaví plánovanie.


\begin{figure}[htb]

\begin{center}

\includegraphics[scale=0.7]{work.jpg} 
\caption{Diagram komunikácie}
\label{work}

\end{center}

\end{figure}
Na obrázku č.\ref{work} je popísané spôsob komunikácie užívateľského rozhrania s PlannerService(OptaPlanner). 1.krokom je vytvorenie XML súboru plánovacieho problému prostredníctvom užívateľského rozhrania a následne uloženie definície do databáze. 2.krok je zaslanie žiadosti s ID úlohy o spustenie/zastavenie prostredníctvom webovej služby PlannerService(OptaPlanner), ktorý žiadosť spracuje. Ten v 3. kroku získa z databáze potrebný definičný XML súbor. Následne sa spustí plánovanie a priebežne sa ukladajú v kroku č. 4 informácie o pokroku úlohy, a čase ukončenia úlohy.Následne užívateľské rozhranie v kroku č. 5 pravidelne získava informácie o úlohe z databáze a zobrazuje ich v prehľadnej tabulke.


\subsection{Návrh modelu databáze}
Na nasledujúcom obrázku je ukázaný ER diagram, ktorý bol použitý pre dtabázu:
\begin{figure}[htb]

\begin{center}

\includegraphics[scale=0.7]{ER.jpg} 
\caption{ER diagram}
\label{ER}

\end{center}

\end{figure}

Tento obrázok zobrazuje jednotlivé entity, ktoré sú potrebné na uloženie v databáze, každá z nich ma určité položky. ER diagram sa skladá z 3 entít: user - entita, ktorá reprezentuje užívateľ, task - entita, ktorá reprezentuje úlohu a organization - entita, ktorá reprezentuje organizáciu. Výsledný návrh odpovedá skutočnosti, že každý užívateľ musí byť súčašťou organizácia, rovnako môže mať vytvorené 0 až N úloh. Taktiež pre zjednodušenie je každa úloha priradená priamo organizácií pre zlepšenie rýchlosti získania výsledkou a zjednodušenia ich nájdenia. Každá entita obsahuje primárny kľúč(jedná sa o silné entitné množiny), ktorý je odvodený od názvu a začína predponou \uv{id\_} a pokračuje názvom entity s CamelCase notáciou(každé slovo začína veľkým písmenom a slová sú spojené dokopy). Poďme sa pozrieť bližšie na jednotlivé entity. Entitná množina organization obsahuje 2 položky jednou z nich je primárny klúč a ďalšou názov organizácia podľa, ktorej sú zaraďovaný jednotlivý užívatelia. Ďalej prejdime k entitnej množine user. Táto entita má rovnako primárny kľúč. Ďalej obsahuje položku pre užívateľské meno(username), heslo(password), email, užívateľskú rolu(role) a cudzí kľúcč organization, ktorý obsahuje na organizáciu. Nakoniec prejdime k entitnej množine task. Táto entitná množina obsahuje primárny kľúč, ďalej obsahuje xml súbor, ktorý reprezentuje danú úlohu(v našom prípade N dám), stav úloh(stateOfTask, ktorý reprezentuje rôzne stavy úlohy), ktorý si podrobnejšie rozobereme. Úloha sa môže nachádzať v jednom z nasledujúcich stavov:
\begin{itemize}
\item NEW - úloha bola vytvorená
\item MODIFIED - xml súbor bol modifikovaný
\item WAITING - úloha čaká na spracovanie
\item IN\_PROGRESS - práve prebieha výpočet
\item PAUSED - úloha je pozastavená
\item COMPLETE - úloha je dokončená
\end{itemize}
Entitná množina task ďalej obsahuje položku, ktorá percentuálne hodnotí stav výpočtu úlohy(progressOfTask), čas do skončenia výpočtu úlohy(eta), nastavenie úlohy na privátnu alebo verejnú(ifPublic), názov úlohy(name) a cudzie kľúce user, ktorý odkazuje na užívateľa, ktorým bola úloha vytvorená a organization, ktorá odkazuje na organizáciu užívateľa, ktorým bola vytvorená. V ďalšej kapitole sa pozrieme na use case diagram.

\subsection{Návrh užívateľského rozhrania}
Výsledné rozhranie kladie dôraz na jednoduchosť a prehľadnosť zobrazených úloh. Z tôhto dôvodu boli implementované mechanizmy vyhľadávanie úloh, organizácií a užívateľov. Rovnako možnosti lexikografického triedenia. Po prihlásení do systému Jednotlivé môžnosti sú následe zakompotované do záložiek, v ktorých je sprístupné príslušná funkčnosť. Výsledné rozhranie je prenositeľné aj na mobilné zaradenie. Užívateľské rozhranie je popísané na nasledujúcom obrázku:
\begin{figure}[htb]

\begin{center}

\includegraphics[scale=0.4]{page_show.jpg} 
\caption{Návrh užívateľského rozhrania}
\label{rozhranie}

\end{center}

\end{figure}
Na obrázku č.\ref{rozhranie} môžme vidieť návrh užívateľského rozhrania. Rozhranie je rozdelené do 6 častí, ktoré môžme rozoznať na obrázku číslami od 1 do 6, ktoré sú aj ohraničené. Celé rozhranie môžme rozdeliť do nasledujúcich častí:
\begin{itemize}
\item Oblasť č.1 predstavuje navigačné menu, kde sú jednotlivé akcie rozdelené do záložiek podľa ich názvu. Pre klinutí na príslušnú záložku sa zmení aj obsah na stránke. 
\item Oblasť č.2 obsahuje informáciu o prihlásenom užívateľovi , rovnako obsahuje aj tlačidlo \uv{Logout}, prostredníctvom ktorého sa môže užívateľ z aplikácie odhlásiť
\item Oblasť č.6 predstavuje funkčnú oblasť. Táto oblasť je špecifická pre každú záložka, ktorá reprezentuje jej obsah. V tej oblasti sú umiestnené typicky obsahy databázových tabuliek, nástroje na vyhľadávanie, rôzne akcie, ktoré je možné vykonávať s dátami, rovnako aj možnosti na vytváranie entít
\item Oblasť č.3 predstavuje jednu z funkčných možností. Jedná sa o vyhľadávanie, ktoré je zložené zo vstupného prvky, do ktorého zadamé vyhľadávaný reťazec a druhá časť predstavuje menu,z ktorého zvolíme stĺpec na vyhľadávanie. Následne je možnosť realizovať tlačidlom Find, ktoré prekreslí obsah tabulky nižšie a naplní ju nájdenými výsledkami.
\item Oblasť č.4 predstavuje tabulky, ktorá je dynamicky obnovaná a reaguje na asychronné ukladanie dát z web service, ktoré sa dynamicky obnovujú každé 4 sekundy. Tabuľka je rozdelená do stĺpcov. Názvy stĺpcov, ktoré sú označené modrou farbou sú zároveň odkazy, na ktoré je možné klinúť. Po kliknutí na daný odkaz dôjde k lexikografickému zoradeniu obsahu tabuľky podla daného stĺpca striedavo vzostupne alebo zostupne. Rád by som upozornil na stĺpec progress, ktorý pre každú úlohu zobrazuje stav spracovania úlohy. Rovnako musím zdôrazniť stĺpec Permission, ktorý zobrazuje, či je úloha verejná alebo privátna. Pokiaľ je úloha verejná(Public), tak je tento odkaz zobrazený modrou farbou, čo znamená, že je odkaz preto je možné naň ho kliknúť. Po kliknutí sa zobrazí stránka s informáciami o názve úlohy a obsahuje výsledného xml súboru. Tento odkaz je možné následne ľubovolne preposlať a pristupovať k nemu. V poslednom rade treba zdôrazniť stĺpec \uv{Actions}, ktorý je najdôležitejší pre každú úlohu povoluje sadu akcií. Jednotlivé akcie sú reprezentované tlačidlami, pritom odrážajú aktuálny stav spracovania úlohy spolu s ďalšími informácimi o úlohe.
\item Oblasť č.5 predstavuje komponentu na stránkovanie, aby pri rozsiahlom obsahu sa nezväčšoval neúmerne veľkosť stránky.


\end{itemize}

Zvyšné návrhy rozhrania pre vytvorenie úlohy, editovanie úlohy, spravovanie užívateľov, spravovanie organizácií, zmenu hesla a prihlasovanie je možné dohľadať v prílohe.


\section{Implementácie}
Aplikácie bola rozložená do viacerých tried podľa zodpovednosti daných komponent. Pri implementácií bolo použité JBoss Developer studo 7.1.1 GA spolu s JBoss AS 7.1.1 Final. Celý projekt boli založený na technológií maven, ktorú uľahčovala celý process vývoja a jeho následne nasadenie na JBoss server. Pre databázovú technológiu bol nainštalovaný mysql server nakonfigurovaný s príslušnými údajmi.

\subsection{Rozdelenie aplikácie}

	Aplikácia bola rozdelená na 2 časti:
	\begin{itemize}
	\item JSF aplikácia s užívateľským rozhraním, ktorá zobrazuje výsledky, umožňuje spravovanie databáze, rovnako aj pristupovanie k službám web service, je pritom rozdelená na hlavný modul s celou funkčnosťou a modul s entitami, ktoré zdieľa s PlannerService - optaplanner.controller
	\item Web service + EJB aplikácia, ktorá poskytuje web service koncový bod spolu s metódami na spustenie a pozastavanie úlohy. Spustenie úlohy volá Message-driven Beanu, ktorá vykonáva spravanie(plánovanie) úlohy, využíva pritom modul Enties, ktorý obsahuje entitné triedy - PlannerService

	\end{itemize}




\subsection{JSF aplikácia}
JSF aplikácia bola postavená na technológií JavaServer Faces v kombinácií s frameworkami Rich Faces, Twitter Boostrap a Font Awesome.  Aplikácia zabezpečuje prihlasovanie užívateľov v kombinácií s bezpečnosťou, ktorá je implementovaná s frameworkom Seam. Je rozdelená na .xhtml stŕanky podľa užívateľskej role. Na každej stránke pritom môžme nájsť komponenty, ktoré dovoluju užívateľovi príslušné akcie. Na .xhtml stránkach sa následne zobrazuje aj obsah spracovania, ktorý už bol prezentovaný tak aj entity užívateľov a organizácií spolu s ich spravovaním. Tieto komunikujú prostredníctvom expression language s managed beananmi na pozadí, ktoré rovnako vykonávajú aj validáciu jednotlivých komponent(od nepovolených hodnot, až po prázdne vstupné polia). Stlačenie príslušného tlačidla spôsoby zavolanie metódy z managed beany a vykonanie akcie, pričom jej obsah môže byť ale nemusí byť zobrazený na .xhtml stránku.
	

\subsection{Prihlasovanie}
Prihlasovanie je realizované prostredníctvom frameworku Seam, z ktorého sme využili moduly Seam Faces a Seam Security. Pre každú užívateľskú roli bolo vytvorené rozhranie a metódy, ktoré overovali indentity užívateľa. Pre prístup musela mať užívateľ danú užívateľskú rolu, pričom prístup bol implementovaný enum-om, v ktorom kažej role, ktorá bola reprezentovaná anotáciou(@Administrator,@Reader, @Planner) boli povolené len im prislúchajúce stránky a bolo deklarované, čo sa má vykonať pri po pokuse o nepovolený prístup(presmerovanie na prihlasovací formulár). Prihlasovanie rovnako obsahovalo validáciu a informovalo užívateľa o nevalidnom hesle, alebo mene. Po úspešnom prihlásení bola do životného cyklu vložená Identita a užívateľ bol presmerovaný na jemu prislúchajúcu stránku. Vloženie identity malu tú výhodu, že bolo možné z managed beany zistiť aký je prihlásený užívateľ. Prihlasovanie overovalo údaje z databáze, pričom pre overenie hesla používalo tŕiedy ShaEncoder, ktorá obsahuje hash funkcia prostredníctvom, ktorej sú zabezpečené všetky heslá v databáze.

\subsection{Logika JSF aplikácie}
V prvom rade trebalo správne nakonfigurovať súbor persistence.xml, aby ukazoval na nami definovaný datasource v rámci aplikačného servera. To umožňuje pristupovanie k dátam v databáze.
Celá logika aplikácie bola sústredná bola sústredená do managead bean, pričom 1 managed beana podľa prihláseného užívateľa(napr. užívatelská rola administrátor na stránke Administrátor.xhtml bola spravovaná managed beanov AdministratorBean). Tie obsahovali metódy a vlastnosti, ktoré bola zobrazované/prevzaté z komponent na .xhtml stránke. Vlasnosti museli spĺňať princíp POJO. Metódy následne volali podľa potreby databázové operácie, ktoré boli sústredené v balíku databaseOP v triede Operation. Tá obsahovala metódy na mazanie, update, vytváranie entít. Predpisy entitných tried sa nachádzali v module Entites. V balíku service sa nachádzali triedy, ktoré umožňujú volanie metód web service.

\subsection{Implementácia rozhrania}
Pre implementáciu rozhrania som využil technológiu xhtml stránok. Pre každú užívateľskú rolu som vytvoril xhtml stránku identitickú s názvom užívateľskej role. Pre prihlasovanie bola použitá Login.xhtml stránka. Na Login.xhtml boli umiestnené komponenty na zadanie užívateľského mena a hesla vrátane skrytých validačných komponent. Pre implementáciu xhtml pre užívateľské role sa zameriam na užívateĽskú rolu Administrátor, keďže rola Plánovač a Čitateľ prevzali všetku implementáciu a komponenty práve od Administrátor, ale len v obmedzenom množstve, teda komponenty vrátane akcií, ktoré mohli vykonávať. XHTML stránka sa skladá v hornej časti z menu, ktoré je implementované ako záložky prostredníctvom Twitter Boostrap-u. V pravej hornej časti sa nachádza informácia o prihlásenom užívatelovi vrátane tlačidla na odhlásnie. Pri kliknutí na záložky sa zobrazí obsah, ktorý odpovedá názvu záložku. Záložky \uv{user management, task, organization management} obsahujú komponenty h:datatable z knižnice JSF pre zobrazenie dát. Tieto dáta sú pravidelné obnovované komponentov z knižnice Rich Faces a4j:poll, ktorý využíva Ajax pre obnovenie obsahu. Každá z tých záložiek obsahuje pole pre vyhľadávanie pričom je možné zvoliť podľa, ktorého stĺpca sa bude vyhľadávať. Výsledky sa zobrazia do tabuľky(h:datatable) pričom zobrazené položky budú odpovedať nájdeným výsledkom. Pri každej položke v tabuľke je možné vykonávať isté akcie ako je vymazať danú entitu, po prípade ju editovať, alebo vykonávať množstvo iných akcií. Akcie pritom reflektujú individuálny stav danej entity.Pri každej z tých záložiek okrem task(ktorú v zápäti rozoberem) je možné entity aj vytvárať. Vytváranie je veľmi jednoduché, keď užívateľ vyplní všetky polia, ktoré musí mať daná entita. Každú tabuľke je možné aj radiť. Radenie prebieha kliknutím na názov stĺpca tabuľky, pričom danú stĺpec implementuje funkciu radenia pre daný stĺpec len v prípade, že názov je vyznačený modrou farbou. Vytváranie úloh(taskov) je zaradené do samostatnej záložky kvôli lepšej prehľadnosti. Užívateľ vyplní meno a prostredníctvom komponenty na nahrávanie súboru z knižnice Rich Faces nahrá obsah do databáze. Ďalej rozoberem záložku change password, ktorá umožňuje si pre daného užívateľa zmeniť heslo, vyplní pritom heslo a potvrdenie heslo a heslo sa zmení. Nakoniec rozoberem záložku edittask, táto záložka je pri bežnom prehliadaní prázna je to spravené kvôli bezpečnosti. Táto záložka sa aktivuje editovaním úlohy v záložke task, ktorá nás prepne do záložky edittask, v ktorej sa už aktivuje obsah a užívateľ vyplní názov úlohy,vlastníka úlohy a nakoniec edituje xml súbor úlohy. Potvrdením sa vytvorí úloha so stavom "MODIFIED".





\subsection{Web Service, EJB aplikácia}
Pri implementácií web service bola využitá už čiastočne implementovaná Web service, do ktorej boli následne doplnená funkčnosť spustenia úlohy a pozastavenia úlohy. Jej časť spustenia výpočtu už nebola cieľom bakalárskej práce a bola teda implementovaná mojim vedúcim Martinom Večeřom.
Táto aplikácia je pomenovaná PlannerService a obsahuje ako som spomínal Big Web servica s 2 metódami. Tieto métody sú metóda runTask s jedným parametrom a to ID úlohy, ktorá sa má spustiť. Pričom dôjde k vytvoreniu spojenia s Message-driven bean,ktorá vykonáva výpočet. Najprv sa do fronty zaradí ID úlohy, ktorá sa má spustiť. Následne si Mesage-driven beana získa z fronty ID úlohy a následne spustí výpočet. Tieto beany sa kvôli rozloženiu záťaže môžu nachádzať na viacerých serveroch. Priebežne pritom aktualizuje stav spracovania úlohy. Priebežne pritom ukladajú údaje o stavu úlohy, času do ukončenia úlohy a percentuálnom ohodnotení úlohy. Po ukončení úlohy je uložené najlepšie možné riešenie do databáze. Na skončení spracovania nastaví príslušný stav úlohy a skončí. Web service obsahuje aj metódu na pozastavenie výpočtu s 1 parametrom a to je ID úlohy, ktoré sa má pozastaviť. Tá následne zavolá Message-driven bean-u, ktorá si z fronty získa úlohu a pozastaví jej výpočet. Tie si úlohu vyberú z actiemsq fronty a spustia výpočet. 
	
	



 
\section{Testovanie}
Testovanie prebiehalo na servery JBoss AS 7.1.1 Final najprv prostredníctvom jednodúch JUnit testov, ktoré malo overiť komplikovanú fukčnosť metód. Následne sa pre overenie fukčnosti databáze použil framework Arqullian, ktorý umožňuje nasadenie tried priamo do Java EE kontajneru, čo zjednodušuje testovanie. Prostredníctvom tohto frameworku sa testovala celková fukčnosť aplikácie. Jednoduchšie časti boli otestované pomocou JUnit testov. Postupným budovaním aplikácie sa pristupovalo k testovaniu navrhnutých častí. Junit boli postupne skonštruované pre jednoduchšie metódy, ako je overenie funkčnosti vyhľadávania entít, mazanie entít, pridanie entít do zoznamu úloh. Pomocou arquallian-u bolo následné otestovaná prihlasovanie, databázové operácie, rovnako bola otestovaná bezpečnosť aplikácie.


V ďalšej častie prebiehalo testovanie medzi konkrétnymi užívateľmi. Užívatelia testovali aplikáciu a hľadali buggy, ktoré neodhalilo predošlé testovanie. Rovnako overovali, či boli splnené formálne požiadavky. Skupine užívateľov bol predložený odkaz na nasadenú aplikáciu a prihlasovacie údaje. Užívatelia mohli následne sa prihlasovať pod rôznymi užívateľskými rolami, tí nasledne testovali vytváranie užívatelov, organizácií, úloh. Následne mohli sledovať stav spracovania plánovacich úloh. Aplikáciu otestovali pod 2 prehliadačmi a to Google Chrome vo verzii 34.0 a Mozilla Firefox verzie 28.0. Bol použitý operačný systém linux 3.13.0-24-generic s operačným systémom Kubuntu 14.04.Aplikácia sa správala pod obomi rovnako a korektne. Po odhalení chýb boli chyby ohlásené a odstránené a aplikácia bola následne opäť nasadená. Tento postup sa opakoval až dokým neboli odhalené všetky chyby. 




\section{Vyhodnotenie aplikácie}
Po testovacej fáze nasledovala fáza vyhodnotenia aplikácie. Cieľovej skupine bol po opravení chýb aplikácie predložený dotazník, do ktoréh výplňami rôzne informácie, kde dávali spätnú väzby, chyby v návrhu, rovnako aj v intuitívnosti ovládania. Cieľovou skupinou bolo 7 eventuálnych používateľov tejto aplikácie. Z dotazníka nám vyplynuli nasledujúce názory a pohľady na aplikáciu.


















\chapter{Záver}\label{zaver}
Plánovanie s ním spojené problémy narážame v bežnom živote čoraz častejšia. Ešte väčšie problémy tohto typu majú organizácie, ktoré musia dennodenne riešiť ako naplánovať efektívnu prácu svojich zamestnancov, ako správne komunikovať so zákazníkom a mnoho iných problémov. Riešenie klasickým prístupom a to využitím ľudskými zdrojmi je časovo neefektívne, rovnako treba brať do úvahy ľudský faktor. Preto vzniklo riešenie, ktoré odbremeňuje organizácie od riešení komplikovaých plánovacích úloh. Taký software je šírený pod licenciou open-source a nazýva sa Optaplanner. Tento systém je následne možné využívať pre akúkoľvek oblasť plánovania, aká len nás napadne. Jediné obmedzenie tohto systému sú použité plánovacie algoritmy kobinovaný s rôznymi heurestikami. Užívateľ je schopný definovať definíciu problému, pričom sa môžme inšpirovať verejne dostupnými príkladmi, vytvoriť si pravidlá a nechať systém nech nájde optimálne riešenie pre daný problém. Vytvorená aplikácia predstavuje jedným zo spôsobov ako daný systém využiť pre plánovanie. Aplikácia je intuitívna, formálne spĺňa požiadavky, rovnako sú predstavené možnosti rožširenia rozhrania a urobenie tohto rozhrania oveľa užívateľsky prívetivejšie.  Rovnako ukazuje akým spôsobom bol systém navrhnutý z implementačného hľadiska, sú vysvetlené technológie potrebné pre implementácui so zreteľom na výhody použitia. Pre systém bol použitý aplikačný server JBoss, ktorý predstavoval medzi dostupnými riešenia najlepší java EE kontajner. Pre lepší návrh by mohla byť aplikácia rozšírená na použitie ich iných plánovacích úloh, rovnako môže byť užívateľské rozhranie rozdelené do viacerých samostatných sekcií kvôli lepšej prehľadnosti. V poslednom rade kvôli lepšej pochopiteľnosti aplikácie by mohla byť JSF aplikácia rozdelená do viacerých balíkov.


